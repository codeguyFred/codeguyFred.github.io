<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[AWS免费科学上网一年]]></title>
    <url>%2F2019%2F10%2F28%2Faws%2F</url>
    <content type="text"><![CDATA[搬瓦工 https://bwh8.net/ Vultr https://www.vultr.com/ jms https://justmysocks1.net/ AWS 注册https://amazonaws-china.com/cn/?nc1=h_ls 1美元信用卡授权https://portal.aws.amazon.com/billing/signup?type=resubscribe#/identityverification 信用卡1美元认证失败的邮件，成功也是这个，需要自行判断，需要看支付方式那里有没有提示 申请进度https://portal.aws.amazon.com/billing/signup?type=resubscribe#/resubscribed 修改支付方式https://console.aws.amazon.com/billing/home?#/paymentmethods 注册成功的邮件（但是不是马上就能用，24后才能用）具体可以查看申请进度页 -选择EC2，如果还没注册通过，则跳转不到下面的页面 选择韩国和启动实例 选择一个免费镜像 学习教程https://amazonaws-china.com/cn/getting-started/use-cases/?awsf.getting-started-use-case=use-case%23websites-apps 申请通过就可以配置一下了 pptphttp://www.zhixinnet.cn/index.php/post/251255.html sshttps://www.textarea.com/Tomaot/2019-nian-zuixin-vultr-yijian-dajian-ss-ssr-jiaoben-xiaobai-kan-le-ye-hui-1173/]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭环]]></title>
    <url>%2F2018%2F05%2F24%2F%E9%97%AD%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[闭环(闭环结构）也叫反馈控制系统，是将系统输出量的测量值与所期望的给定值相比较，由此产生一个偏差信号，利用此偏差信号进行调节控制，使输出值尽量接近于期望值 基础概念闭环(闭环结构）也叫反馈控制系统，是将系统输出量的测量值与所期望的给定值相比较，由此产生一个偏差信号，利用此偏差信号进行调节控制，使输出值尽量接近于期望值。 互联网的闭环O2O平台将用户引流到线下之后再返回到线上形成闭环https://www.zhihu.com/question/20624296 营销的闭环通过效果检测，让 campaign 中每一个平台、每一项内容的效果可观察可衡量，并用于这个或下个 campaign 的进一步优化 管理的闭环闭环管理是综合闭环系统、管理的封闭原理、管理控制、信息系统等原理形成的一种管理方法。它把全公司的供一产一销管理过程作为一个闭环系统，使系统和子系统内的管理构成连续封闭和回路且使系统活动维持在一个平衡点上，进而使矛盾和问题得到及时解决，决策、控制、反馈、再控制、再反馈。…从而在循环积累中不断提高，促进企业超越自我不断发展 闭环思维做事情到一定节点做出反馈http://www.xinli001.com/info/100376380]]></content>
      <categories>
        <category>thinking</category>
      </categories>
      <tags>
        <tag>感想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[180416-0422周报]]></title>
    <url>%2F2018%2F04%2F23%2F180416-0422%E5%91%A8%E6%8A%A5%2F</url>
    <content type="text"><![CDATA[由于易道内存紧张问题，所以尝试用多进程的方式去处理，常用于webview或者加载bitmap多的Activity… 由于易道内存紧张问题，所以尝试用多进程的方式去处理，常用于webview或者加载bitmap多的Activity， Android中比较方便就可以分开多个进程,只要在activity节点下设置1android:process=":customroom" 就可以新建一个进程，运行后在控制台可以看到“:”前方是当前应用的包名，当然你也可以用其他包名，多个进程间的对象是不能直接引用的，因为会重走Application的onCreate，也就是单个程序可以有一个或者多个进程。进程进程间通信有很多种方式，比如常见的点击浏览器中的url就可以跳转到某个应用中，其中用到的就是Bundle，包括其他的诸如广播和服务也是，还有的是ContentProvider，Messenger（类似于Handler）。 而常见的是用AIDL(Android Interface Definition Language)，这是后缀为.aidl的文件，这个就是一种定义接口的语言关于aidl可以看这个通讯的例子，相当于客户端和服务端通信，aidl定义的接口作为中介。这篇比较详细，不过我之前看的不是这篇文章，不见了http://cjw-blog.net/2017/02/26/AIDL/ 而Hermes是饿了么的一个IPC（Inter-Process Communication（进程间通信））通讯框架，封装了AIDL，通过注解的形式可以像单一进程那样使用对象或方法。不过我在用到易道的时候还有点问题，具体等下篇成功使用后的总结。 还有一个整理书签的时候发现，双守护进程就是使用两个进程分别装载两个Service，在两个Service中开轮询，互相唤醒（https://blog.csdn.net/aigestudio/article/details/51348408） 简单介绍如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.aigestudio.daemon"&gt; &lt;application&gt; &lt;service android:name=".services.DaemonService" android:process=":service" /&gt; &lt;service android:name=".services.ProtectService" android:process=":remote" /&gt; &lt;/application&gt;&lt;/manifest&gt;/** * @author AigeStudio * @since 2016-05-05 */public class DaemonService extends Service &#123; private static boolean sPower = true, isRunning; @Override public IBinder onBind(Intent intent) &#123; return null; &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; if (!isRunning) &#123; isRunning = true; new Thread(new Runnable() &#123; @Override public void run() &#123; while (sPower) &#123; if (System.currentTimeMillis() &gt;= 123456789000000L) &#123; sPower = false; &#125; Log.d("AigeStudio", "DaemonService"); startService(new Intent(DaemonService.this, ProtectService.class)); SystemClock.sleep(3000); &#125; &#125; &#125;).start(); &#125; return super.onStartCommand(intent, flags, startId); &#125;&#125;/** * @author AigeStudio * @since 2016-05-05 */public class ProtectService extends Service &#123; private static boolean sPower = true, isRunning; @Override public IBinder onBind(Intent intent) &#123; return null; &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; if (!isRunning) &#123; isRunning = true; new Thread(new Runnable() &#123; @Override public void run() &#123; while (sPower) &#123; if (System.currentTimeMillis() &gt;= 123456789000000L) &#123; sPower = false; &#125; SystemClock.sleep(1500); Log.d("AigeStudio", "ProtectService"); startService(new Intent(ProtectService.this, DaemonService.class)); &#125; &#125; &#125;).start(); &#125; return super.onStartCommand(intent, flags, startId); &#125;&#125; 关于闪屏页的一点处理 崩溃时重走闪屏页 https://www.jianshu.com/p/4fc10026c1f8 返回应用显示广告 https://juejin.im/post/59634e85f265da6c3d6c35ef]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[180401-0408周报]]></title>
    <url>%2F2018%2F04%2F08%2F180401-0408%E5%91%A8%E6%8A%A5%2F</url>
    <content type="text"><![CDATA[关于new Handler().post（new Runnable()）的实现原理… 关于new Handler().post（new Runnable()）的实现原理View添加到布局当中会有延时，addView不是立即生效的。 addView之后对相关View进行查找和搜索可能会是空的; 或者相关的属性，比如getTop(),getY(),getLeft(),getX()可能会是0，或者-1，-2； 而通过post，可以将相关操作加入消息队列中，待addView或者xml相关View初始化完成后进行处理，而post能在主线中回调，是因为在ActivityThread的main方法中已经声明了主线程的消息队列，所以直接post的话是加到了主线程的消息队列中 https://blog.csdn.net/ly502541243/article/details/52062179/ 123public final boolean post(Runnable r)&#123;return sendMessageDelayed(getPostMessage(r), 0);&#125; 关于ActivityThread 也可以通过回调接口判断1234//子View添加public void onViewAdded(View child) &#123;&#125;//子View移除public void onViewRemoved(View child) &#123;&#125; 1234567891011setOnHierarchyChangeListener(new OnHierarchyChangeListener() &#123; @Override public void onChildViewAdded(View parent, View child) &#123; &#125; @Override public void onChildViewRemoved(View parent, View child) &#123; &#125; &#125;);]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译优化]]></title>
    <url>%2F2018%2F02%2F27%2F%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[链接 https://droidyue.com/blog/2017/04/16/speedup-gradle-building/ http://www.yopai.com/show-1-184902-1.html http://blog.csdn.net/xiangyunwan/article/details/72677369 http://blog.csdn.net/geyanyan0911/article/details/53117514 减少编译可能存在的重复步骤，比如通过apt批量生成网络层代码，不需要每次都执行，只需要生成完成后将代码拷贝到相关包下，确切来说通过切片的方式去批量生成代码不太合适，只是借用这种切片的方法]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中性词]]></title>
    <url>%2F2017%2F07%2F30%2F%E6%84%9F%E6%83%B3%2F</url>
    <content type="text"><![CDATA[人们所理解的坏是相对的，褒义词和贬义词在我看来应该从中性词的角度去理解，并不是所有被赋予贬义的事物本质上都是贬义的，或者说贬义的事物本身不全都是贬义的。人们所理解的坏是相对的，褒义词和贬义词在我看来应该从中性词的角度去理解，并不是所有被赋予贬义的事物本质上都是贬义的，或者说贬义的事物本身不全都是贬义的。]]></content>
      <categories>
        <category>thinking</category>
      </categories>
      <tags>
        <tag>感想</tag>
      </tags>
  </entry>
</search>